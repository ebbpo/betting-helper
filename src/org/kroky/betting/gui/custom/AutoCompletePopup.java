/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package org.kroky.betting.gui.custom;

import foxtrot.AsyncTask;
import foxtrot.AsyncWorker;
import java.awt.*;
import java.awt.event.*;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.TreeSet;
import java.util.regex.Pattern;
import javax.swing.*;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.JTextComponent;
import org.apache.log4j.Logger;
import org.jdesktop.swingx.JXTable;
import org.jdesktop.swingx.sort.RowFilters;
import org.jdesktop.swingx.sort.TableSortController;
import org.kroky.betting.common.util.Utils;
import org.kroky.betting.gui.custom.tables.SingleColumnTableModel;

/**
 *
 * @author Kroky
 */
public class AutoCompletePopup extends EscapableDialog {
    private static final Logger LOG = Logger.getLogger(AutoCompletePopup.class);
    /**
     * Creates new form AutoCompletePopup
     */
    private AutoCompletePopup(JDialog parent, Collection<?> options, JTextComponent textComponent) {
        super(parent, false);
        this.parent = parent;
        this.component = textComponent;
        initComponents();
        additionalInit(options);
    }
    
    private AutoCompletePopup(JFrame parent, Collection<?> options, JTextComponent textComponent) {
        super(parent, false);
        this.parent = parent;
        this.component = textComponent;
        initComponents();
        additionalInit(options);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setResizable(false);
        setUndecorated(true);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 183, javax.swing.GroupLayout.PREFERRED_SIZE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 300, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane1;
    // End of variables declaration//GEN-END:variables

    private Window parent;
    private JTextComponent component;
    private JXTable table;
    private DocumentListener autoCompleteListener = new AutoCompleteListener();
    private FocusListener componentFocusListener = new ComponentFocusListener();
    private static final Map<JTextComponent, AutoCompletePopup> decoratedComponents = new HashMap<JTextComponent,AutoCompletePopup>();
    
    private void additionalInit(Collection<?> options) {
        table = new JXTable(new SingleColumnTableModel(new TreeSet<Object>(options)));
        table.setTableHeader(null);
        table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        table.addFocusListener(new FocusAdapter() {

            @Override
            public void focusGained(FocusEvent e) {
                if(table.getSelectedRowCount() == 0 && table.getRowCount() > 0) {
                    table.getSelectionModel().addSelectionInterval(0, 0);
                }
            }

            @Override
            public void focusLost(FocusEvent e) {
                AsyncWorker.post(new HideTask());
            }
            
        });
        table.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                new SelectTeamAction().actionPerformed(null);
            }
        });
        table.addMouseMotionListener(new MouseMotionAdapter() {
            @Override
            public void mouseMoved(MouseEvent e) {
                int row = table.rowAtPoint(e.getPoint());
                table.getSelectionModel().setSelectionInterval(row, row);
            }
            
        });
        jScrollPane1.setViewportView(table);
        
        //only hide when esc pressed
        getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), "escapePressed");
        getRootPane().getActionMap().put("escapePressed", new AbstractAction() {

            @Override
            public void actionPerformed(ActionEvent e) {
                hidePopup();
            }
        });
        component.addFocusListener(componentFocusListener);
        component.getDocument().addDocumentListener(autoCompleteListener);
        component.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, 0), "goToAutoComplete");
        component.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), "escapePressed");
        component.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0), "selectTeam");
        component.getActionMap().put("goToAutoComplete", new GoToAutoCompleteAction());
        component.getActionMap().put("escapePressed", new EscapePressedAction());
        component.getActionMap().put("selectTeam", new SelectTeamAction());
        
        table.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0), "selectTeam");
        table.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_TAB, 0), "none");
        table.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(KeyEvent.VK_TAB, InputEvent.SHIFT_DOWN_MASK), "focusBackward");
        table.getActionMap().put("selectTeam", new SelectTeamAction());
        table.getActionMap().put("focusBackward", new FocusBackwardAction());
    }
    
    private void filter(String typedSoFar) {
        String regex = ".*" + typedSoFar + ".*";
        RowFilter<Object, Object> filter = RowFilters.regexFilter(Pattern.CASE_INSENSITIVE, regex);
        TableSortController rowSorter = (TableSortController) table.getRowSorter();
        rowSorter.setRowFilter(filter);
    }
    
    private void showPopup() {
        if(isShowing()) {
            return;
        }
        //show below the component, aligned to the right side of the component
        Rectangle bounds = component.getBounds();
        Point locationOnScreen = component.getLocationOnScreen();
        Dimension thisSize = this.getSize();
        
        //components lower right corner coordinates
        int componentLowerRightX = locationOnScreen.x + bounds.width;
        int componentLowerRightY = locationOnScreen.y + bounds.height;
        
        int x = componentLowerRightX - thisSize.width;
        int y = componentLowerRightY;
        
        setLocation(x, y);
        setVisible(true);
    }
    
    private void hidePopup() {
        setVisible(false);
    }
    
    private void selectFirst() {
        if(table.getRowCount() > 0) {
            table.getSelectionModel().addSelectionInterval(0, 0);
        }
    }
    
    public static void decorate(Collection<?> options, JTextComponent component) {
            Container parent = component.getParent();
            AutoCompletePopup popup = null;
            while(parent != null) {
                if(parent instanceof JDialog) {
                    popup = new AutoCompletePopup((JDialog) parent, options, component);
                    break;
                } else if(parent instanceof JFrame) {
                    popup = new AutoCompletePopup((JFrame) parent, options, component);
                    break;
                }
                parent = parent.getParent();
            }
            if(popup == null) {
                LOG.error("Cannot decorate. Decorated component must be child of a frame or dialog.");
            } else {
                decoratedComponents.put(component, popup);
            }
    }
    
    public static void undecorate(JTextComponent component) {
        
        if(decoratedComponents.containsKey(component)) {
            AutoCompletePopup popup = decoratedComponents.remove(component);
            component.getDocument().removeDocumentListener(popup.autoCompleteListener);
            component.removeFocusListener(popup.componentFocusListener);
            component.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).remove(KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, 0));
            component.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).remove(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0));
            component.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).remove(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0));
        } else {
            LOG.warn("Cannot undecorate. Component not decorated.");
        }
    }
    
    private class AutoCompleteListener implements DocumentListener {
        
        @Override
        public void insertUpdate(DocumentEvent e) {
            change();
        }

        @Override
        public void removeUpdate(DocumentEvent e) {
            change();
        }

        @Override
        public void changedUpdate(DocumentEvent e) {
            change();
        }

        private void change() {
            String text = component.getText();
            if(Utils.isEmpty(text)) {
                return;
            }
            if(!isShowing()) {
                showPopup();
            }
            filter(text);
            selectFirst();
            component.requestFocus();
        }
    }
    
    private class GoToAutoCompleteAction extends AbstractAction {

        @Override
        public void actionPerformed(ActionEvent e) {
            if(isShowing()) {
                if(table.getRowCount() > 1) {
                    table.getSelectionModel().addSelectionInterval(1, 1);
                } else {
                    selectFirst();
                }
            } else {
                showPopup();
                filter(component.getText());
                selectFirst();
            }
            AutoCompletePopup.this.table.requestFocus();
        }

    }
    
    private class SelectTeamAction extends AbstractAction {

        @Override
        public void actionPerformed(ActionEvent e) {
            component.getDocument().removeDocumentListener(autoCompleteListener);
            String selectedOption = table.getStringAt(table.getSelectedRow(), 0);
            component.setText(selectedOption);
            hidePopup();
            component.getDocument().addDocumentListener(autoCompleteListener);
        }

    }
    
    private class FocusBackwardAction extends AbstractAction {

        @Override
        public void actionPerformed(ActionEvent e) {
            component.requestFocus();
            component.selectAll();
        }

    }
    
    private class EscapePressedAction extends AbstractAction {

        @Override
        public void actionPerformed(ActionEvent e) {
            if(AutoCompletePopup.this.isShowing()) {
                hidePopup();
            } else {
                parent.dispose();
            }
        }
    }
    
    private class HideTask extends AsyncTask {

        @Override
        public Object run() throws Exception {
            Thread.sleep(100);
            if(!component.isFocusOwner()) {
                hidePopup();
            }
            return null;
        }

        @Override
        public void success(Object result) {
            //nothing to do
        }

        @Override
        public void failure(Throwable ex) {
            LOG.warn(ex.getMessage(), ex);
        }
    }
    
    private class ComponentFocusListener extends FocusAdapter {
        @Override
        public void focusLost(FocusEvent e) {
            Component parent = e.getOppositeComponent();
            while(parent != null) {
                if(parent instanceof AutoCompletePopup) {
                    break;
                }
                parent = parent.getParent();
            }
            if(parent == null) {
                hidePopup();
            }
        }
        
    }
}
