/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package org.kroky.betting.gui.graph;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.io.File;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import javax.swing.WindowConstants;
import org.apache.commons.io.FileUtils;
import org.apache.log4j.Logger;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
import org.jfree.data.xy.XYDataset;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;
import org.kroky.betting.common.enums.BetStatus;
import org.kroky.betting.common.enums.MatchResult;
import org.kroky.betting.common.util.Utils;
import org.kroky.betting.db.objects.Bet;
import org.kroky.betting.db.objects.Provider;
import org.kroky.betting.db.objects.Team;
import org.kroky.betting.parsers.ParseResult;
import org.kroky.betting.parsers.Parser;
import org.kroky.betting.parsers.impl.BetExplorerResultsHTMLParser;
import org.kroky.betting.parsers.impl.BetExplorerResultsHockeyHtmlParser;

/**
 *
 * @author Kroky
 */
public class GraphFrame extends javax.swing.JFrame {

    private static final Logger LOG = Logger.getLogger(GraphFrame.class);

    /**
     * Creates new form GraphFrame
     */
    public GraphFrame(List<Bet> bets) {
        initComponents();
        additionalInit(bets);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        scrollPane = new javax.swing.JScrollPane();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Profit Progress");
        getContentPane().add(scrollPane, java.awt.BorderLayout.CENTER);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane scrollPane;
    // End of variables declaration//GEN-END:variables

    private void additionalInit(List<Bet> bets) {
        //bets = createBets();
        ChartPanel chartPanel = createChartPanel(bets, false);
        scrollPane.setViewportView(chartPanel);
        pack();
    }

    private ChartPanel createChartPanel(List<Bet> bets, boolean legend) {
        ChartPanel chartPanel = new ChartPanel(createChart(createDataset(bets), legend));
        chartPanel.setMouseWheelEnabled(true);
        //we'll use the mainframe size instead
        //set the preferred size as 60% of the screen resolution
        //Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
        //int width = (int) (screenSize.getWidth() * 0.6);
        //int height = (int) (screenSize.getHeight() * 0.6);
        int width = (int) ((double) getParent().getWidth() * 0.7);
        int height = (int) ((double) getParent().getHeight() * 0.7);
        chartPanel.setPreferredSize(new Dimension(width, height));
        chartPanel.setInitialDelay(0);
        chartPanel.setDismissDelay(20000);
        chartPanel.setReshowDelay(0);
        return chartPanel;
    }

    private JFreeChart createChart(XYDataset xyDataSet, boolean legend) {
        JFreeChart jfreechart = ChartFactory.createXYLineChart("Profit Progress", "Bets", "Profit", xyDataSet, PlotOrientation.VERTICAL, legend, true, false);
        XYPlot xyplot = (XYPlot) jfreechart.getPlot();
        xyplot.setDomainPannable(true);
        xyplot.setRangePannable(true);
        xyplot.setDomainZeroBaselineVisible(true);
        xyplot.setRangeZeroBaselineVisible(true);
        NumberAxis betAxis = (NumberAxis) xyplot.getDomainAxis();
        betAxis.setStandardTickUnits(NumberAxis.createIntegerTickUnits());
        betAxis.setMinorTickCount(0);
        XYLineAndShapeRenderer renderer = (XYLineAndShapeRenderer) xyplot.getRenderer();
        renderer.setDrawOutlines(true);
        renderer.setUseFillPaint(true);
        renderer.setBaseFillPaint(Color.white);
        renderer.setToolTipGenerator(new BetTooltipGenerator());
        final int seriesCount = ((XYSeriesCollection) xyDataSet).getSeriesCount();
        for (int i = 0; i < seriesCount; i++) {
            renderer.setSeriesShapesVisible(i, true);
            renderer.setSeriesStroke(i, new BasicStroke(1F));
            renderer.setSeriesOutlineStroke(i, new BasicStroke(1F));
            renderer.setSeriesShape(i, new java.awt.geom.Ellipse2D.Double(-3D, -3D, 6D, 6D));
        }
        return jfreechart;
    }

    private XYDataset createDataset(List<Bet> bets) {
        return createDataset(bets, false);
    }

    private XYDataset createDataset(List<Bet> bets, boolean sort) {
        XYSeriesCollection xySeriesCollection = new XYSeriesCollection();
        XYSeries xySeries = new XYSeries("S");
        if (sort) {
            Collections.sort(bets);
        }
        double profit = 0;
        int i = 1;
        xySeries.add(BetDataItem.EMPTY);
        for (Bet bet : bets) {
            if (bet.getStatus().equals(BetStatus.ACTIVE)) {
                continue;
            }
            profit += bet.getProfit();
            BetDataItem item = new BetDataItem(i++, profit, bet);
            xySeries.add(item);

        }
        xySeriesCollection.addSeries(xySeries);
        return xySeriesCollection;
    }

    /**
     * FOR DEBUG PURPOSES AND PLOTTING GRAPH FROM URLS
     * @param series
     */
    public GraphFrame(XYDataset series) {
        initComponents();
        additionalInit(series);
    }

    private void additionalInit(XYDataset xyDataSet) {
        //bets = createBets();
        ChartPanel chartPanel = new ChartPanel(createChart(xyDataSet, true));
        scrollPane.setViewportView(chartPanel);
        pack();
    }

    //for debug purposes
    private List<Bet> createBets() {
        ArrayList<Bet> list = new ArrayList<Bet>();
        Random rnd = new Random(System.currentTimeMillis());
        for (int i = 0; i < 3000; i++) {
            Bet bet = new Bet();
            bet.setMatchDate(new Timestamp(2000 + i, 0, 1, 0, 0, 0, 0));
            bet.setBetValue(new Double(rnd.nextInt(10) + 1));
            bet.setOdds(new Double(new Double(rnd.nextInt(40) + 300) / 100.0));
            bet.setFlStatus(rnd.nextInt(4) == 1 ? 1 : 0);
            list.add(bet);
        }
        return list;
    }

    /************************************************************************
     *
     * SOME NOTES:
     *
     * NO_DRAWS_SOCCER   - start betting when team has <NO_DRAWS> matches in row without a draw - applies for soccer
     * NO_DRAWS_HOCKEY   - start betting when team has <NO_DRAWS> matches in row without a draw - applies for hockey
     * RATIO             - how much you would like to get back NETTO after you win the bet. Ratio of 1.0 means you'll get back exactly the value of the bet, 0.5 means you'll get half, ...
     *                   - keep it in mind this rule: RATIO must be less than (ODDS - 1)
     * FIRST_3_BETS      - these are the bets that are not computed dynamically and are placed on first 3 matches
     *                   - cannot be lower than 0.5 because probably no betting agency accepts bets less than 0.5 â‚¬
     * USE_DYNAMIC_RATIO - if bets get too high you can lower the return ratio based on the values in the DYNAMIC_RATIO map - if set to true, RATIO is ignored
     * DYNAMIC_RATIO     - first number is the upper limit of the bet, second is the ratio that is used if the bet is LOWER than the first number
     * WHOLE_SEASON      - true/false - if false set the START_DATE to the date you wish to simulate placing bets
     * START_DATE        - date (in format yyyy-MM-dd 00:00:00.000) from where you want the graph to be calculated (i.e. like no bets were placed before this date)
     * URLS              - first is always season (or any identifier you like to display in the chart) - PLEASE USE FILE SAFE CHARACTERS, no /, \, :, > and so on
     *                   - the the rest are urls of which you want content to be combined together (e.g. NHL pre season results, regular season and playoffs)
     *                   - the order of URLs is not important - results will be sorted by the match date
     * ALIASES           - if throughout the seasons one team changes name, add the changed name to the map with value of its previous name
     */
    private static final int NO_DRAWS_SOCCER = 0;
    private static final int NO_DRAWS_HOCKEY = 0;
    private static final double RATIO = 1.0;

    private static final double[] FIRST_3_BETS;

    static {
        if (RATIO <= 1.0) {
//            FIRST_3_BETS = new double[]{0.5, 1.0, 1.5};
//            FIRST_3_BETS = new double[]{1.0, 2.0, 3.0};
//            FIRST_3_BETS = new double[]{0.5, 0.5, 0.5};
            FIRST_3_BETS = new double[]{2.0, 4.0, 6.0};
        } else {
            FIRST_3_BETS = new double[]{0.5 * RATIO, 1.0 * RATIO, 1.5 * RATIO};
//            FIRST_3_BETS = new double[]{1.0 * RATIO, 2.0 * RATIO, 3.0 * RATIO};
//            FIRST_3_BETS = new double[]{1.0, 2.0, 3.0};
        }
    }

    private static final boolean USE_DYNAMIC_RATIO = false;
    private static final TreeMap<Double, Double> DYNAMIC_RATIO = new TreeMap<Double, Double>();

    /* NOT RISKY */
//    static {
//        DYNAMIC_RATIO.put(0.0, RATIO * 1.00);
//        DYNAMIC_RATIO.put(40.0, RATIO * 0.80);
//        DYNAMIC_RATIO.put(70.0, RATIO * 0.60);
//        DYNAMIC_RATIO.put(100.0, RATIO * 0.40);
//        DYNAMIC_RATIO.put(130.0, RATIO * 0.20);
//        DYNAMIC_RATIO.put(160.0, RATIO * 0.00);
//    }

    /* MORE RISKY */
    static {
        DYNAMIC_RATIO.put(0.0, RATIO * 1.00);
        DYNAMIC_RATIO.put(60.0, RATIO * 0.90);
        DYNAMIC_RATIO.put(80.0, RATIO * 0.80);
        DYNAMIC_RATIO.put(110.0, RATIO * 0.50);
        DYNAMIC_RATIO.put(150.0, RATIO * 0.20);
        DYNAMIC_RATIO.put(200.0, RATIO * 0.10);
        DYNAMIC_RATIO.put(230.0, RATIO * 0.00);
    }

    private static final boolean WHOLE_SEASON = true;
    private static final Timestamp START_DATE = Utils.stringToTimestamp("2000-07-12 00:00:00.000");

    private static final boolean EXCLUSION_ACTIVE = true;
    private static final HashSet<String> EXCLUDED_TEAMS = new HashSet<String>();

    static {
//        EXCLUDED_TEAMS.add("Harrach");
//        EXCLUDED_TEAMS.add("Constantine");
        EXCLUDED_TEAMS.add("Batna");
        EXCLUDED_TEAMS.add("Tlemcen");
        EXCLUDED_TEAMS.add("Bel Abbes");
        EXCLUDED_TEAMS.add("Ain Fakroun");
//        EXCLUDED_TEAMS.add("Kabylie");
//        EXCLUDED_TEAMS.add("MO Bejaia");
        EXCLUDED_TEAMS.add("Eulma");
        EXCLUDED_TEAMS.add("Bel Abbes");
        EXCLUDED_TEAMS.add("Annaba");
        EXCLUDED_TEAMS.add("USM Blida");
        EXCLUDED_TEAMS.add("Bordj Bou Arreridj");
//        EXCLUDED_TEAMS.add("ES Setif");
        EXCLUDED_TEAMS.add("Bejaia");
        EXCLUDED_TEAMS.add("ASO Chlef");
//        EXCLUDED_TEAMS.add("USM Alger");
        EXCLUDED_TEAMS.add("Saida");
        EXCLUDED_TEAMS.add("Hussein Dey");
        EXCLUDED_TEAMS.add("Khroub");
//        EXCLUDED_TEAMS.add("Oran");
        EXCLUDED_TEAMS.add("");
        EXCLUDED_TEAMS.add("");

    }

    private static final HashMap<String, String> ALIASES = new HashMap<String, String>();

    static {
        ALIASES.put("", "");

    }

    private static final String[][] URLS = new String[][]{
        //        {"Brazil Soccer 2012",
        //            "http://www.betexplorer.com/soccer/brazil/campeonato-brasileiro/results/",
        //        },
        //        {"Brazil Soccer 2011",
        //            "http://www.betexplorer.com/soccer/brazil/campeonato-brasileiro-2011/results/",
        //        },
        //        {"Brazil Soccer 2010",
        //            "http://www.betexplorer.com/soccer/brazil/campeonato-brasileiro-2011/results/",
        //        },
        //        {"Argentina Soccer 2012",
        //            "http://www.betexplorer.com/soccer/argentina/primera-division/results/",
        //        },
        //        {"Argentina Soccer 2011",
        //            "http://www.betexplorer.com/soccer/argentina/primera-division-2011-2012/results/?stage=zyViEZxb",
        //            "http://www.betexplorer.com/soccer/argentina/primera-division-2011-2012/results/?stage=ERTeDgh4",},
        //        {"Morocco 2010 - 2014",
        //            "http://www.betexplorer.com/soccer/morocco/botola-pro-2014-2015/results/",
        //            "http://www.betexplorer.com/soccer/morocco/botola-2013-2014/results/",
        //            "http://www.betexplorer.com/soccer/morocco/botola-2012-2013/results/",
        //            "http://www.betexplorer.com/soccer/morocco/botola-2011-2012/results/",
        //            "http://www.betexplorer.com/soccer/morocco/botola-2010-2011/results/",},
        {"Algeria 2010 - 2015",
            "http://www.betexplorer.com/soccer/algeria/division-1/results/",
            "http://www.betexplorer.com/soccer/algeria/division-1-2014-2015/results/",
            "http://www.betexplorer.com/soccer/algeria/division-1-2013-2014/results/",
            "http://www.betexplorer.com/soccer/algeria/division-1-2012-2013/results/",
            "http://www.betexplorer.com/soccer/algeria/division-1-2011-2012/results/",
            "http://www.betexplorer.com/soccer/algeria/division-1-2010-2011/results/",},};

    //<editor-fold defaultstate="collapsed" desc="---<<< MAIN METHOD >>>---">
    public static void main(String args[]) {
        /*
         * Set the Nimbus look and feel
         */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /*
         * If Nimbus (introduced in Java SE 6) is not available, stay with the
         * default look and feel. For details see
         * http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (Exception ex) {
        }
        //</editor-fold>

        /*
         * Create and display the dialog
         */
        java.awt.EventQueue.invokeLater(new Runnable() {

            @Override
            public void run() {
                GraphFrame frame = null;
                try {
                    frame = new GraphFrame(createSeries(URLS));
                    frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
                    //frame.setExtendedState(javax.swing.JFrame.MAXIMIZED_BOTH);
                    frame.setLocationRelativeTo(null);
                    frame.setVisible(true);
                } catch (Exception exception) {
                    if (frame != null) {
                        frame.dispose();
                    }
                    LOG.error(exception.getMessage(), exception);
                }
            }
        });
    }
    //</editor-fold>

    private static XYSeriesCollection createSeries(String[][] urls) throws Exception {
        //<editor-fold defaultstate="collapsed" desc="...">
        XYSeriesCollection xySeriesCollection = new XYSeriesCollection();
        for (int i = 0; i < urls.length; i++) {
            List<Bet> bets = createBets(urls[i]);
            XYSeries xySeries = new XYSeries(urls[i][0], false);
            double profit = 0;
            xySeries.add(BetDataItem.EMPTY);
            int j = 1;
            for (Bet bet : bets) {
                if (bet.getStatus().equals(BetStatus.ACTIVE)) {
                    continue;
                }
                profit += bet.getProfit();
                BetDataItem item = new BetDataItem(j++, profit, bet);
                xySeries.add(item);
            }
            xySeriesCollection.addSeries(xySeries);
        }
        return xySeriesCollection;
        //</editor-fold>
    }

    private static double maxBet = 0.0;
    private static TreeMap<String, Double> teamMaxBet = new TreeMap<String, Double>();

    private static List<Bet> createBets(String[] urls) throws Exception {
        TreeSet<ParseResult> allResults = new TreeSet<ParseResult>();
        //0 is not a URL
        for (int i = 1; i < urls.length; i++) {
            Parser p = null;
            List<ParseResult> currentResults;
            if (urls[i].contains("soccer")) {
                Provider provider = new Provider(null, "soccer", null, null, null, null);
                StringBuilder sb = new StringBuilder(provider.getControlText());
                sb.append(Utils.getHtmlFromUrl(urls[i]));
                LOG.info("Got HTML from url: " + urls[i]);
                p = new BetExplorerResultsHTMLParser();
                currentResults = new ArrayList<ParseResult>(p.parse(sb.toString()));
            } else if (urls[i].contains("hockey")) {
                Provider provider = new Provider(null, "hockey", null, null, null, null);
                StringBuilder sb = new StringBuilder(provider.getControlText());
                sb.append(Utils.getHtmlFromUrl(urls[i]));
                LOG.info("Got HTML from url: " + urls[i]);
                p = new BetExplorerResultsHockeyHtmlParser();
                currentResults = new ArrayList<ParseResult>(p.parse(sb.toString()));
            } else {
                throw new RuntimeException("Dunno which parser to use");
            }
            LOG.info("Parsed.");
            //write them to the file in the same order we received them
//            String filename = urls[0] + " - Results from url " + i + ".txt";
//            FileUtils.writeLines(new File(filename), currentResults);
//            LOG.info("Written file: " + filename);
            //this will order them from oldest to newest
            TreeSet<ParseResult> sortedSet = new TreeSet<ParseResult>(currentResults);
            LOG.info("Sorted.");
//            filename = urls[0] + " - Reversed results from url " + i + ".txt";
//            FileUtils.writeLines(new File(filename), sortedSet);
//            LOG.info("Written file: " + filename);
            allResults.addAll(sortedSet);
        }
        String filename = urls[0] + " - Combined results.txt";
        FileUtils.writeLines(new File(filename), allResults);
        LOG.info("Written file: " + filename);

        HashMap<String, Team> name2Team = new HashMap<String, Team>();
        int teamId = 1;
        List<Bet> bets = new ArrayList<Bet>();
        int betId = 1;
        HashMap<String, Integer> noDraws = new HashMap<String, Integer>();

        LOG.info("Simulating betting with factors NO_DRAWS_SOCCER=" + NO_DRAWS_SOCCER + ", NO_DRAWS_HOCKEY=" + NO_DRAWS_SOCCER + ", RATIO=" + (USE_DYNAMIC_RATIO ? "dynamic" : RATIO));
        for (ParseResult r : allResults) {
            String homeTeamName = ALIASES.get(r.getHomeTeamName()) == null ? r.getHomeTeamName() : ALIASES.get(r.getHomeTeamName());
            String awayTeamName = ALIASES.get(r.getAwayTeamName()) == null ? r.getAwayTeamName() : ALIASES.get(r.getAwayTeamName());

            String teamName = "Vancouver Canucks";
            //false if you want all teams included, false if only the 1 above
            boolean justOneTeam = false;
            if (justOneTeam && !(homeTeamName.equals(teamName) || awayTeamName.equals(teamName))) {
                continue;
            }

            if (!name2Team.containsKey(homeTeamName)) {
                Team team = new Team(homeTeamName, "Sport", "Country", "League");
                team.setId(teamId++);
                name2Team.put(homeTeamName, team);
                noDraws.put(homeTeamName, 0);
                teamMaxBet.put(homeTeamName, 0.0);
            }
            if (!name2Team.containsKey(awayTeamName)) {
                Team team = new Team(awayTeamName, "Sport", "Country", "League");
                team.setId(teamId++);
                name2Team.put(awayTeamName, team);
                noDraws.put(awayTeamName, 0);
                teamMaxBet.put(awayTeamName, 0.0);
            }

            Team homeTeam = name2Team.get(homeTeamName);
            Team awayTeam = name2Team.get(awayTeamName);

            boolean shouldPlaceBet = true;
            if (justOneTeam) {
                shouldPlaceBet = homeTeamName.equals(teamName);
            }
            boolean dateOK = r.getDate().equals(START_DATE) || r.getDate().after(START_DATE) || WHOLE_SEASON;

            int noDrawCount = r.getSport().equals("hockey") ? NO_DRAWS_HOCKEY : NO_DRAWS_SOCCER;
            if (noDraws.get(homeTeamName) < noDrawCount && dateOK) {
                LOG.info("Still waiting for " + homeTeamName + " to have enough non-draw matches. Current: " + noDraws.get(homeTeamName) + " Required: " + noDrawCount);
            }
            boolean skipHomeTeam = EXCLUSION_ACTIVE && EXCLUDED_TEAMS.contains(homeTeamName);
            if ((homeTeam.hasIncompleteChain() || noDraws.get(homeTeamName) >= noDrawCount) && dateOK && shouldPlaceBet && !skipHomeTeam) {
                Bet bet = new Bet();
                bet.setId(betId++);
                bet.setMatchDate(r.getDate());
                bet.setCreated(Utils.now());
                bet.setUpdated(Utils.now());
                bet.setHomeTeam(homeTeam);
                bet.setAwayTeam(awayTeam);
                bet.setActiveTeam(homeTeam);
                bet.setStatus(BetStatus.ACTIVE);
                bet.setOdds(r.getOdds());
                setNextBetValue(bet.getActiveTeam(), bet);
                bet.getActiveTeam().addBet(bet);
                LOG.info("Placed bet on " + homeTeamName + ": " + bet.getBetValue());
                bet.setStatus(r.getResult().equals(MatchResult.DRAW) ? BetStatus.WON : BetStatus.LOST);
                if (teamMaxBet.get(homeTeamName) < bet.getBetValue()) {
                    teamMaxBet.put(homeTeamName, bet.getBetValue());
                    maxBet = maxBet < bet.getBetValue() ? bet.getBetValue() : maxBet;
                }
                bets.add(bet);
            }
            noDraws.put(homeTeamName, r.getResult().equals(MatchResult.DRAW) ? 0 : noDraws.get(homeTeamName) + 1);

            shouldPlaceBet = true;
            if (justOneTeam) {
                shouldPlaceBet = awayTeamName.equals(teamName);
            }
            if (noDraws.get(awayTeamName) < noDrawCount && dateOK) {
                LOG.info("Still waiting for " + awayTeamName + " to have enough non-draw matches. Current: " + noDraws.get(awayTeamName) + " Required: " + noDrawCount);
            }
            boolean skipAwayTeam = EXCLUSION_ACTIVE && EXCLUDED_TEAMS.contains(awayTeamName);
            if ((awayTeam.hasIncompleteChain() || noDraws.get(awayTeamName) >= noDrawCount) && dateOK && shouldPlaceBet && !skipAwayTeam) {
                Bet bet = new Bet();
                bet.setId(betId++);
                bet.setMatchDate(r.getDate());
                bet.setCreated(Utils.now());
                bet.setUpdated(Utils.now());
                bet.setHomeTeam(homeTeam);
                bet.setAwayTeam(awayTeam);
                bet.setActiveTeam(awayTeam);
                bet.setStatus(BetStatus.ACTIVE);
                bet.setOdds(r.getOdds());
                setNextBetValue(bet.getActiveTeam(), bet);
                bet.getActiveTeam().addBet(bet);
                LOG.info("Placed bet on " + awayTeamName + ": " + bet.getBetValue());
                bet.setStatus(r.getResult().equals(MatchResult.DRAW) ? BetStatus.WON : BetStatus.LOST);
                if (teamMaxBet.get(awayTeamName) < bet.getBetValue()) {
                    teamMaxBet.put(awayTeamName, bet.getBetValue());
                    maxBet = maxBet < bet.getBetValue() ? bet.getBetValue() : maxBet;
                }
                bets.add(bet);
            }
            if (dateOK) {
                LOG.info("Bet " + (MatchResult.DRAW.equals(r.getResult()) ? " WON" : " LOST"));
            }
            noDraws.put(awayTeamName, r.getResult().equals(MatchResult.DRAW) ? 0 : noDraws.get(awayTeamName) + 1);
        }
        for (Bet bet : bets) {
            System.out.println(bet);
        }
        LOG.info("Teams and their highest bets:\n" + Utils.mapToString(teamMaxBet));
        //LOG.info("Max bet: " + maxBet);
        return bets;
    }

    private static void setNextBetValue(Team team, Bet nextBet) {
        double totalSumInvested = 0.0;
        final Set<Bet> currentBetChain = team.getCurrentBetChain();
        int betCount = currentBetChain.size();
        double betValue;
        for (Bet bet : currentBetChain) {
            totalSumInvested += bet.getBetValue();
        }
        if (betCount < FIRST_3_BETS.length) {
            betValue = FIRST_3_BETS[betCount];
        } else {
            //betValue = Utils.roundUp(totalSumInvested / (odds - 1 - ratio));
            double ratio = RATIO;
            betValue = Utils.roundUp(totalSumInvested / (nextBet.getOdds() - 1.0 - ratio));
            if (USE_DYNAMIC_RATIO) {
                for (double limit : DYNAMIC_RATIO.keySet()) {
                    if (betValue < limit) {
                        ratio = DYNAMIC_RATIO.get(limit);
                        break;
                    }
                    ratio = DYNAMIC_RATIO.get(limit);
                }
                betValue = Utils.roundUp(totalSumInvested / (nextBet.getOdds() - 1.0 - ratio));
            }
        }
        //if(nextBet.getOdds())
        nextBet.setBetValue(betValue);
    }
}
